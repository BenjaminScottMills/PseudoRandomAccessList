# PseudoRandomAccessList

The pseudo-random-access list (pral) is a sequence container consisting of a binary tree overlaid on a portion of the nodes of a doubly-linked list.

Prals can store elements in any order. They also support iterators which take a constant time to move forward or backward by one element.

It is optimised for a combination of accessing elements by index (O(sqrt(n)) time complexity) and mutation (insert/erase) at beginning, end, or middle (O(sqrt(n)) time complexity). While this is inferior to a self-balancing binary tree modified to store elements (sorted or not) in a linear arrangement (which has O(Log(n)) time complexity for both of those operations), iteration through a pral is faster (as the number of elements increases, the time it takes to iterate through a pral approaches half the time it takes to iterate through a balanced binary tree). All in all, this means that a pral is mostly inferior to some other sequence container; since vectors allow for faster iteration than prals due to storing elements in a contiguous block, a pral can only be the most efficient sequence container for a hypothetical algorithm involving element access, mutation at the middle, and iteration (occuring infrequently enough relative to mutation that a vector doesn't become the fastest option). Another barrier to pral's practicality is that there is no quick way to add elements to a pral, so it can take a long time to create large prals if elements are added one at a time.

efficiencyDemonstration.cpp compares a pral with a vector, list, and AVL Tree (modified to act as a sequence container) as they perform modification at arbitrary indices (a combination of access and mutation operations) and iteration to show an example of an "algorithm" in which a pral is the most efficient choice (ignoring the time it takes to create the sequence containers, which doesn't change as algorithm length increases).

efficiencyDemoList.cpp, efficiencyDemoPral.cpp, efficiencyDemoSBBTree.cpp, and efficiencyDemoVector.cpp run the algorithm on each sequence container seperately (efficiencyDemonstration.cpp takes a long time to run because previous sequence containers must be cleared for them to be fairly judged when the number of elements is this large, and clearing a Pral or List is quite slow).

efficiencyDemoAccuracy.cpp runs the algorithm from efficiencyDemo.cpp untimed with a smaller number of elements and doesn't clear the sequence containers, and verifies that the 4 sequence containers are the same at the end of it. This is both to demonstrate that the algorithm is implemented the same across the 4 sequence containers, and to show that pral functions correctly.
